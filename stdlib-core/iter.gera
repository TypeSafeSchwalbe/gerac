
mod std::iter

pub proc map(iter, mapping) {
    return || {
        case iter() {
            #end -> return #end unit
            #next n -> return #next mapping(n)
        }
    }
}

pub proc filter(iter, condition) {
    return || {
        var result = { val = #end unit }
        exhaust(|| {
            var current
            case iter() {
                #end -> return #end unit
                #next n -> current = n
            }
            case condition(current) -> {
                result.val = #next current
                return #end unit
            }
            return #next unit
        })
        return result.val
    }
}

pub proc reduce(iter, reduction, initial) {
    var value = { val = initial }
    iter |> map(|v| {
        value.val = reduction(value.val, v)
    }) |> exhaust()
    return value.val
}

pub proc take(iter, n) {
    var taken = { count = 0 }
    return || {
        case taken.count >= n -> return #end unit
        taken.count = taken.count + 1
        return iter()
    }
}

pub proc skip(iter, n) {
    iter |> take(n) |> exhaust()
    return iter
}

pub proc for_each(iter, action) {
    iter |> map(action) |> exhaust()
}

pub proc zip(iter_a, iter_b, combinator) {
    return || {
        var val_a
        case iter_a() {
            #end -> return #end unit
            #next v -> val_a = v
        }
        var val_b
        case iter_b() {
            #end -> return #end unit
            #next v -> val_b = v
        }
        return #next combinator(val_a, val_b)
    }
}

pub proc chain(iter_a, iter_b) {
    return || {
        case iter_a() {
            #next n -> return #next n
            #end -> {}
        }
        return iter_b()
    }
}

pub proc count(iter, condition) {
    var found = { count = 0 }
    exhaust(|| {
        case iter() {
            #end -> return #end unit
            #next n -> case condition(n) -> {
                found.count = found.count + 1
            }
        }
        return #next unit
    })
    return found.count
}

pub proc next(iter) {
    case iter() {
        #end -> return #none unit
        #next v -> return #some v
    }
}

pub proc last(iter) {
    var result = { value = #none unit }
    iter |> for_each(|v| {
        result.value = #some v
    })
    return result.value
}

pub proc from_value(value) {
    mut var done = false
    return || {
        case done -> return #end unit
        done = true
        return #next value
    }
}

pub proc find(iter, condition) {
    return iter |> filter(condition) |> next()
}